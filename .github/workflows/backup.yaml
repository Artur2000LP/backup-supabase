name: respaldo-supabase

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * *" # Se ejecuta todos los dÃ­as a medianoche

env:
  BACKUP_ENABLED: true

jobs:
  ejecutar_respaldo_bd:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
      BACKUP_ENABLED: ${{ vars.BACKUP_ENABLED }} # Variable del repositorio (true o false)
    steps:
      - name: Verificar si los respaldos estÃ¡n habilitados
        run: |
          if [ "$BACKUP_ENABLED" != "true" ]; then
            echo "Los respaldos estÃ¡n deshabilitados. Saliendo del flujo de trabajo."
            exit 0
          fi

      - name: Clonar repositorio
        if: env.BACKUP_ENABLED == 'true'
        uses: actions/checkout@v3

      - name: Configurar CLI de Supabase
        if: env.BACKUP_ENABLED == 'true'
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Crear carpeta con fecha
        if: env.BACKUP_ENABLED == 'true'
        run: |
          BACKUP_DATE=$(date +%Y-%m-%d)
          BACKUP_TIME=$(date +%H-%M-%S)
          BACKUP_DIR="prisma/backups/$BACKUP_DATE"
          mkdir -p "$BACKUP_DIR"
          echo "BACKUP_DIR=$BACKUP_DIR" >> $GITHUB_ENV
          echo "BACKUP_DATE=$BACKUP_DATE" >> $GITHUB_ENV
          echo "BACKUP_TIME=$BACKUP_TIME" >> $GITHUB_ENV
          echo "Creando respaldo en: $BACKUP_DIR"

      - name: Respaldar roles y esquema
        if: env.BACKUP_ENABLED == 'true'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_DB_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          echo "Respaldando esquema desde API REST de Supabase..."
          
          # Crear backup del esquema usando curl y la API de Supabase
          curl -X GET "$SUPABASE_URL/rest/v1/" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" > "$BACKUP_DIR/api_info.json"
          
          # Obtener lista de tablas
          curl -X GET "$SUPABASE_URL/rest/v1/information_schema.tables?select=table_name&table_schema=eq.public" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
            -H "Content-Type: application/json" > "$BACKUP_DIR/tables_list.json"
          
          # Crear script SQL bÃ¡sico con estructura
          echo "-- Respaldo de Supabase generado el $(date)" > "$BACKUP_DIR/schema.sql"
          echo "-- URL: $SUPABASE_URL" >> "$BACKUP_DIR/schema.sql"
          echo "-- Fecha: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$BACKUP_DIR/schema.sql"
          
          echo "âœ… Respaldo de API completado"

      - name: Respaldar datos por tabla
        if: env.BACKUP_ENABLED == 'true'
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_DB_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        run: |
          echo "Respaldando datos desde API REST..."
          
          # Lista de tablas comunes que suelen existir
          COMMON_TABLES=("users" "profiles" "posts" "orders" "products" "categories" "auth.users")
          
          # Crear archivo de datos
          echo "-- Respaldo de datos generado el $(date)" > "$BACKUP_DIR/data.sql"
          echo "-- Este archivo contiene los datos exportados via API REST" >> "$BACKUP_DIR/data.sql"
          
          # Intentar respaldar tablas comunes
          for table in "${COMMON_TABLES[@]}"; do
            echo "Intentando respaldar tabla: $table"
            response=$(curl -s -w "%{http_code}" -X GET "$SUPABASE_URL/rest/v1/$table?select=*" \
              -H "apikey: $SUPABASE_SERVICE_KEY" \
              -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" \
              -H "Content-Type: application/json" \
              -o "$BACKUP_DIR/table_${table}.json")
            
            if [ "${response: -3}" = "200" ]; then
              echo "âœ… Tabla $table respaldada exitosamente"
              echo "-- Datos de tabla: $table" >> "$BACKUP_DIR/data.sql"
              cat "$BACKUP_DIR/table_${table}.json" >> "$BACKUP_DIR/data.sql"
              echo "" >> "$BACKUP_DIR/data.sql"
            else
              echo "âš ï¸ Tabla $table no encontrada o sin acceso (cÃ³digo: ${response: -3})"
            fi
          done
          
          # Respaldar esquemas disponibles
          curl -s -X GET "$SUPABASE_URL/rest/v1/information_schema.columns?select=*" \
            -H "apikey: $SUPABASE_SERVICE_KEY" \
            -H "Authorization: Bearer $SUPABASE_SERVICE_KEY" > "$BACKUP_DIR/schema_info.json" || echo "Schema info no disponible"
          
          echo "âœ… Respaldo de datos completado"

      - name: ðŸ”’ Encriptar archivos sensibles
        if: env.BACKUP_ENABLED == 'true'
        env:
          ENCRYPTION_KEY: ${{ secrets.BACKUP_ENCRYPTION_KEY }}
        run: |
          echo "ðŸ” Encriptando archivos de backup..."
          
          # Instalar herramientas de encriptaciÃ³n
          sudo apt-get update && sudo apt-get install -y gpg
          
          # Encriptar archivos sensibles
          echo "$ENCRYPTION_KEY" | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 --output "$BACKUP_DIR/schema.sql.enc" "$BACKUP_DIR/schema.sql"  
          echo "$ENCRYPTION_KEY" | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 --output "$BACKUP_DIR/data.sql.enc" "$BACKUP_DIR/data.sql"
          
          # Encriptar archivos JSON tambiÃ©n
          if [ -f "$BACKUP_DIR/api_info.json" ]; then
            echo "$ENCRYPTION_KEY" | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 --output "$BACKUP_DIR/api_info.json.enc" "$BACKUP_DIR/api_info.json"
          fi
          
          if [ -f "$BACKUP_DIR/tables_list.json" ]; then
            echo "$ENCRYPTION_KEY" | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 --output "$BACKUP_DIR/tables_list.json.enc" "$BACKUP_DIR/tables_list.json"
          fi
          
          # Eliminar archivos sin encriptar
          rm -f "$BACKUP_DIR"/*.sql "$BACKUP_DIR"/*.json "$BACKUP_DIR"/table_*.json
          
          # Crear archivo de verificaciÃ³n
          echo "Archivos encriptados correctamente con AES256" > "$BACKUP_DIR/ENCRYPTED_README.txt"
          echo "Para desencriptar: gpg --decrypt archivo.sql.enc > archivo.sql" >> "$BACKUP_DIR/ENCRYPTED_README.txt"
          
          echo "âœ… EncriptaciÃ³n completada - Datos protegidos"

      - name: Crear enlace a Ãºltimo respaldo
        if: env.BACKUP_ENABLED == 'true'
        run: |
          cd prisma/backups
          rm -f latest
          ln -s "$BACKUP_DATE" latest
          echo "Ãšltimo respaldo enlazado a: $BACKUP_DATE"

      - name: Crear manifiesto del respaldo
        if: env.BACKUP_ENABLED == 'true'
        run: |
          cat > "$BACKUP_DIR/manifest.json" << EOF
          {
            "fecha_respaldo": "$BACKUP_DATE",
            "hora_respaldo": "$BACKUP_TIME",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "archivos_encriptados": {
              "esquema": "schema.sql.enc", 
              "datos": "data.sql.enc",
              "api_info": "api_info.json.enc",
              "tables_list": "tables_list.json.enc"
            },
            "metodo": "API_REST",
            "encriptacion": "AES256",
            "supabase_url": "${{ secrets.SUPABASE_DB_URL }}",
            "nota_seguridad": "Backup via API REST - Todos los archivos estÃ¡n encriptados. Usa BACKUP_ENCRYPTION_KEY para desencriptar."
          }
          EOF
          echo "Manifiesto de respaldo creado"

      - name: Confirmar respaldos
        if: env.BACKUP_ENABLED == 'true'
        uses: stefanzweifel/git-auto-commit-action@v4
        with:
          commit_message: Respaldo de Supabase
